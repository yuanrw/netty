/*
 * Copyright 2020 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License,
 * version 2.0 (the "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */
package io.netty.buffer;

import java.io.IOException;
import java.io.Writer;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Random;

/**
 * test allocations, and write layout of chunks to a file.
 */
public final class PoolChunkLayoutBenchmark extends AbstractBenchmark {

    private static final char FULL = 'g';
    private static final char FRAGMENTED = 'b';
    private static final char FREE = 'k';

    private static final char[] PAGES_LAYOUT = new char[CHUNK_SIZE / PAGE_SIZE];

    private static final int QUEUE_SIZE = 40;

    /**
     * generated by {@link #generateRandomSize}
     */
    private static final int[] RANDOM_SIZE = {
            275480, 68819, 211122, 357369, 327819, 331735, 446366, 215806, 35697, 399530, 365527, 351980, 206703,
            336134, 264429, 323156, 189482, 382840, 181097, 321433, 281999, 331886, 35975, 153540, 204249, 68158, 86709,
            414888, 345388, 286465, 82943, 446058, 58723, 217252, 72674, 224283, 327626, 344683, 132645, 409149, 361411,
            250142, 67879, 250953, 328456, 182561, 365018, 326814, 160207, 394277, 270434, 55143, 389587, 81122, 107132,
            36737, 409956, 188327, 286146, 70433, 254326, 277180, 409045, 166817, 175315, 249747, 192411, 242962,
            151337, 266032, 337345, 233428, 165290, 363433, 200962, 360008, 306082, 98955, 278122, 429896, 277984,
            283739, 366872, 271200, 271347, 259612, 59349, 443515, 348147, 179484, 431456, 247849, 371816, 125612,
            125807, 411852, 346440, 330077, 333330, 119074
    };

    private PoolChunkLayoutBenchmark() {
    }

    public static void main(String[] args) throws IOException {
        new PoolChunkLayoutBenchmark().startBench("memory-layout-benchmark.txt");
    }

    @Override
    protected void doBench(Writer writer) throws IOException {
        Queue<ByteBuf> queue = new LinkedList<ByteBuf>();
        for (int size : RANDOM_SIZE) {
            if (queue.size() == QUEUE_SIZE) {
                //release half
                while (queue.size() > QUEUE_SIZE / 2) {
                    free(queue.poll());
                }
            }

            ByteBuf buf = allocate(size);
            //write current layout to the file
            writeToFile(writer);

            if (buf == null) {
                System.out.println("out of memory");
            } else {
                queue.offer(buf);
            }
        }

        //test over, release all bufs
        while (!queue.isEmpty()) {
            queue.poll().release();
        }
    }

    private static ByteBuf allocate(int size) {
        try {
            ByteBuf buf = ALLOCATOR.buffer(size);

            PooledByteBuf<ByteBuffer> b = convert2PooledByteBuf(buf);

            int start = b.offset / PAGE_SIZE;
            int pages = b.maxLength / PAGE_SIZE;

            for (int i = 1; i <= pages; i++) {
                if (i * PAGE_SIZE <= size || (i - 1) * PAGE_SIZE < size) {
                    //full or half used
                    PAGES_LAYOUT[start + i - 1] = FULL;
                } else {
                    PAGES_LAYOUT[start + i - 1] = FRAGMENTED;
                }
            }

            return buf;
        } catch (OutOfMemoryError e) {
            return null;
        }
    }

    private static void free(ByteBuf buf) {
        if (buf != null) {
            PooledByteBuf<ByteBuffer> b = convert2PooledByteBuf(buf);

            int start = b.offset / PAGE_SIZE;
            int pages = b.maxLength / PAGE_SIZE;

            //set pages to free
            for (int i = 0; i < pages; i++) {
                PAGES_LAYOUT[start + i] = FREE;
            }
            buf.release();
        }
    }

    private static void writeToFile(Writer writer) throws IOException {
        StringBuilder colorSb = new StringBuilder();
        StringBuilder lenSb = new StringBuilder();

        boolean first = true;

        int len = 0;
        char last = ' ';
        for (char c : PAGES_LAYOUT) {
            if (c == 0) {
                c = FREE;
            }
            if (last == ' ') {
                len++;
                last = c;
            } else if (c == last) {
                len++;
            } else if (c != last) {
                if (first) {
                    colorSb.append(last);
                    lenSb.append(len);
                    first = false;
                } else {
                    colorSb.append(',').append(last);
                    lenSb.append(',').append(len);
                }
                len = 1;
                last = c;
            }
        }

        if (len > 0) {
            if (first) {
                colorSb.append(last);
                lenSb.append(len);
            } else {
                colorSb.append(',').append(last);
                lenSb.append(',').append(len);
            }
        }

        writer.write(lenSb.toString());
        writer.write("\r\n");
        writer.write(colorSb.toString());
        writer.write("\r\n");
        writer.flush();
    }

    @SuppressWarnings("unchecked")
    private static PooledByteBuf<ByteBuffer> convert2PooledByteBuf(ByteBuf buf) {
        PooledByteBuf<ByteBuffer> b;
        if (buf instanceof PooledByteBuf) {
            b = (PooledByteBuf<ByteBuffer>) buf;
        } else {
            SimpleLeakAwareByteBuf s = (SimpleLeakAwareByteBuf) buf;
            b = (PooledByteBuf<ByteBuffer>) s.buf;
        }
        return b;
    }

    static void generateRandomSize() {
        int[] randomSize = new int[100];
        int lowBound = 28673;

        Random rand = new Random();
        for (int i = 0; i < randomSize.length; i++) {
            //make total request size smaller than chunk size
            randomSize[i] = lowBound + rand.nextInt((CHUNK_SIZE - lowBound) / QUEUE_SIZE + 1);
        }
        System.out.println(Arrays.toString(randomSize));
    }
}
