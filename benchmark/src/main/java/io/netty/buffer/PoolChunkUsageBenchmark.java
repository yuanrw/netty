/*
 * Copyright 2020 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License,
 * version 2.0 (the "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */
package io.netty.buffer;

import java.io.IOException;
import java.io.Writer;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Random;

/**
 * test allocations, and write request bytes and used bytes after each allocation to a file.
 */
public final class PoolChunkUsageBenchmark extends AbstractBenchmark {

    /**
     * generated by {@link #generateRandomSize}
     */
    private static final int[] RANDOM_SIZE = {
            1559886, 4329893, 6040149, 15965903, 16511955, 15869673, 12619151, 10534801, 14208198, 4920754, 2900130,
            7714627, 16561210, 15195004, 11641637, 9573846, 16029798, 1112641, 2051878, 14159926, 11269419, 871996,
            13609151, 10973404, 1105474, 5365193, 6167889, 6659968, 3019268, 14488937, 13270112, 7610860, 7167700,
            2105825, 2438155, 4536300, 14243116, 4733569, 11266854, 4961377, 9560131, 2760066, 15475446, 189813,
            5140312, 8122505, 12266120, 11038185, 10033566, 15251272, 16403886, 12157323, 13510340, 3801668, 3815831,
            7890627, 6465056, 15943601, 794890, 7192395, 9997943, 837753, 12642879, 11278847, 10924139, 9687899,
            11780186, 15585226, 12187010, 15915056, 10576517, 12187087, 14789961, 14150312, 11136586, 1048127, 10635509,
            4998600, 15774588, 12824962, 8384799, 6182905, 15238275, 6958483, 12067603, 13989377, 4431930, 9523174,
            8410465, 9506443, 12699355, 1471022, 10323418, 5766405, 12115154, 15423944, 16643512, 11612182, 16566445,
            12731335
    };

    private static final long[] REQ_BYTES = new long[100];
    private static final long[] USED_BYTES = new long[100];

    private static long reqBytes;

    private PoolChunkUsageBenchmark() {
    }

    public static void main(String[] args) throws IOException {
        //the result file
        new PoolChunkUsageBenchmark().startBench("memory-usage-benchmark.txt");
    }

    @Override
    protected void doBench(Writer writer) throws IOException {
        Queue<ByteBuf> queue = new LinkedList<ByteBuf>();

        for (int i = 0; i < RANDOM_SIZE.length; i++) {
            if (queue.size() == 10) {
                //release half
                while (queue.size() > 5) {
                    free(queue.poll());
                }
            }

            ByteBuf buf = allocate(RANDOM_SIZE[i]);
            //record current request bytes
            REQ_BYTES[i] = reqBytes;
            if (buf == null) {
                System.out.println("out of memory");
            } else {
                queue.offer(buf);
            }

            long usedBytes = 0;
            PoolArenaMetric arena = ALLOCATOR.heapArenas().get(0);
            List<PoolChunkListMetric> chunkListMetrics = arena.chunkLists();
            for (int j = 0; j < chunkListMetrics.size(); j++) {
                for (PoolChunkMetric m : chunkListMetrics.get(j)) {
                    usedBytes += m.chunkSize() - m.freeBytes();
                }
            }

            //record current used bytes
            USED_BYTES[i] = usedBytes;
        }

        //test over, release all
        for (ByteBuf buf : queue) {
            buf.release();
        }

        //write request bytes and used bytes to the file
        writer.write(Arrays.toString(REQ_BYTES));
        writer.write("\r\n");
        writer.write(Arrays.toString(USED_BYTES));
        writer.write("\r\n");
    }

    private static ByteBuf allocate(int size) {
        try {
            ByteBuf buf = ALLOCATOR.buffer(size);
            reqBytes += size;
            return buf;
        } catch (OutOfMemoryError e) {
            return null;
        }
    }

    private static void free(ByteBuf buf) {
        reqBytes -= buf.capacity();
        buf.release();
    }

    static void generateRandomSize() {
        int[] randomSize = new int[100];
        //max small size + 1
        int lowBound = 28673;
        Random rand = new Random();
        for (int i = 0; i < randomSize.length; i++) {
            randomSize[i] = lowBound + rand.nextInt(CHUNK_SIZE - lowBound + 1);
        }
    }
}
