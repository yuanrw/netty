/*
 * Copyright 2020 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License,
 * version 2.0 (the "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */
package io.netty.buffer;

import java.io.IOException;
import java.io.Writer;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Random;

public final class PoolChunkUsageSmallBenchmark extends AbstractBenchmark {

    /**
     * generated by {@link #generateRandomSize}
     */
    private static final int[] RANDOM_SIZE = {
            1175, 7319, 1682, 2807, 6225, 1203, 4463, 6285, 1644, 7212, 2023, 7146, 1832, 5362, 4002, 479, 755, 1035,
            7842, 4136, 1234, 851, 4080, 1693, 922, 3436, 1668, 7841, 2381, 7111, 5521, 391, 3599, 7286, 5161, 6662,
            611, 2134, 6221, 2590, 6497, 7974, 5972, 2351, 1796, 818, 6477, 3115, 2304, 5440, 4328, 7759, 7770, 2300,
            7676, 1685, 4152, 4641, 4745, 7115, 4375, 564, 6012, 5840, 7548, 5027, 6602, 5613, 2992, 5722, 2892, 8190,
            5250, 2869, 5050, 7095, 2952, 3816, 6627, 3559, 7249, 708, 4033, 5539, 1118, 2219, 3312, 1093, 3858, 2235,
            1127, 282, 7992, 2584, 382, 6228, 5886, 7174, 1375, 5843
    };

    private static final long[] REQ_BYTES = new long[100];
    private static final long[] USED_BYTES = new long[100];

    private static long reqBytes;

    private PoolChunkUsageSmallBenchmark() {
    }

    public static void main(String[] args) throws IOException {
        //the result file
        new PoolChunkUsageSmallBenchmark().startBench("memory-usage-benchmark-small.txt");
    }

    @Override
    protected void doBench(Writer writer) throws IOException {
        Queue<ByteBuf> queue = new LinkedList<ByteBuf>();

        for (int i = 0; i < RANDOM_SIZE.length; i++) {
            if (queue.size() == 10 * 1000) {
                //release half
                while (queue.size() > 5 * 1000) {
                    free(queue.poll());
                }
            }

            //since it's small, we allocate more
            int cnt = 1000;
            while (cnt-- > 0) {
                ByteBuf buf = allocate(RANDOM_SIZE[i]);
                if (buf == null) {
                    System.out.println("out of memory");
                } else {
                    queue.offer(buf);
                }
            }

            //record current request bytes
            REQ_BYTES[i] = reqBytes;

            long usedBytes = 0;
            PoolArenaMetric arena = ALLOCATOR.heapArenas().get(0);
            List<PoolChunkListMetric> chunkListMetrics = arena.chunkLists();
            for (int j = 0; j < chunkListMetrics.size(); j++) {
                for (PoolChunkMetric m : chunkListMetrics.get(j)) {
                    usedBytes += m.chunkSize() - m.freeBytes();
                }
            }

            //record current used bytes
            USED_BYTES[i] = usedBytes;
        }

        //test over, release all
        for (ByteBuf buf : queue) {
            buf.release();
        }

        //write request bytes and used bytes to the file
        writer.write(Arrays.toString(REQ_BYTES));
        writer.write("\r\n");
        writer.write(Arrays.toString(USED_BYTES));
        writer.write("\r\n");
    }

    private static ByteBuf allocate(int size) {
        try {
            ByteBuf buf = ALLOCATOR.buffer(size);
            reqBytes += size;
            return buf;
        } catch (OutOfMemoryError e) {
            return null;
        }
    }

    private static void free(ByteBuf buf) {
        reqBytes -= buf.capacity();
        buf.release();
    }

    static void generateRandomSize() {
        int[] randomSize = new int[100];
        Random rand = new Random();
        for (int i = 0; i < randomSize.length; i++) {
            randomSize[i] = 1 + rand.nextInt(PAGE_SIZE + 1);
        }
    }
}
